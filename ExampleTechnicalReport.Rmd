---
output: 
  pdf_document:
    highlight: tango
    keep_tex: FALSE
    fig_caption: FALSE
    latex_engine: pdflatex
author: Michael Geden
title: "Challenges in the Visualization of Sleep Deprivation across the US"
abstract: "Sleep deprivation is a wide-spread public health issue in the United States and many other countries. Rising awareness of the issue has led to large-scale epidemiological efforts to measure the prevalance and cost of the issue. Visualization of this information is crucial for informing policy and planning targeted interventions to populations in need, however, visualizing the data often involves a large number of decisions on the preprocessing of the data which can influence the conclusions made. This brief report touches on a few of these challenges, and provides some recommendations for transparency. "
geometry: margin=1in
sansfont: Calibri Light
fontsize: 11pt
bibliography: template/mybib.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(dplyr)
library(maps)
library(stringr)
load("data/2009_sleepdef_clean.rdata") 
quintiles <- function(x){
    qnt <- quantile(x, seq(0,1, by=.20))
    cut <- cut(x, unique(qnt), include.lowest=TRUE,
               ordered_result = TRUE)
    lvls <- levels(cut)
    newlevels <- sapply(lvls, function(x) {
        x2 <- substr(x, 2, nchar(x)-1)
        x3 <- gsub(",","-",x2)
        x3
    })
    output <- plyr::mapvalues(cut, from = lvls, to = newlevels)
    output
}
BRFSS_geoextraction <- function(filepath, id = "county", position,
                                extraction, contiguous=TRUE,latlong=TRUE,
                                func = function(x) {mean(x, na.rm=T)}) {
    # Error Catching
    if(!grepl("state", tolower(position[1]))){stop("State must be first position.")}
    if(!is.character(filepath)) {stop("Filepath must be character")}
    if(!is.character(position)) {stop("Position must be character")}
    if(!is.character(extraction)) {stop("Extraction variable must be character name.")}
    if(length(extraction)!=1) {stop("Function currently only accepts one extracted var.")}
    if(!id %in% c("county", "state")) {stop("ID must be county or state.")}
    if(id == "county" & length(position) != 2) {
        stop("County level requires position to have State and County varialbe names. ")
    }
    # Setup
    require(SASxport)
    require(dplyr)
    require(maps)
    require(stringr)
    require(ggplot2)
    strsplit2 <- function(x, char, index){
        unlist(strsplit(x, char))[index]
    }
    clear_labels <- function(x) {
        if(is.list(x)) {
            for(i in 1 : length(x)) class(x[[i]]) <- setdiff(class(x[[i]]), 'labelled')
            for(i in 1 : length(x)) attr(x[[i]],"label") <- NULL
        }
        else {
            class(x) <- setdiff(class(x), "labelled")
            attr(x, "label") <- NULL
        }
        return(x)
    }
    # Read Data
    data <- read.xport(filepath) %>%
        clear_labels(.)
    # Subset
    keep <- c(position, extraction)
    keep.states <- if(contiguous) {
        c(15, 2, 66, 72, 78)
    } else {c()}
    # Remove Excess
    data2 <- data %>%
        select(one_of(keep)) %>% # Select columns of interest
        filter(!(!!rlang::sym(position[1])) %in% keep.states) %>% # Select States
        filter(!(is.na(!!rlang::sym(position[1])))) # remove missing states
    if(id == "county"){
        data2 <- data2 %>%
            filter(!(!!rlang::sym(position[2])) %in% c(777,999)) %>%
            filter(!(is.na(!!rlang::sym(position[2])))) %>%
            mutate(FIPS = as.numeric(paste0(
                !!rlang::sym(position[1]), str_pad(!!rlang::sym(position[2]),3, pad = "0"), sep = "")
            ))
    } else {
        data2 <- data2 %>%
            mutate(FIPS = !!rlang::sym(position[1]))
    }
    # Get FIPS Codes
    if(id == "county") {
        data(county.fips)
        county.fips$polyname <- sapply(county.fips$polyname, function(x) {
            unlist(strsplit(x, ":"))[1]
        })
        county.fips <- unique(county.fips)
        fips.codes <- county.fips
    } else {
        data(state.fips)
        state.fips$polyname <- sapply(state.fips$polyname, function(x) {
            unlist(strsplit(x, ":"))[1]
        })
        state.fips <- unique(state.fips)
        fips.codes <- as.data.frame(state.fips)
    }
    varname <- paste0(extraction, ".f", sep = "")
    # Merge By FIPS
    data3 <- data2 %>%
        left_join(fips.codes, by = c("FIPS" = "fips")) %>% # Get location string
        group_by(polyname,FIPS) %>% # State/County-wise operations
        summarize(!!varname := func(!!rlang::sym(extraction)), # Proportion of sleep deficiency
                  n = sum(!is.na(!!rlang::sym(extraction))), # Frequency of response
                  prop.responded = sum(!is.na(!!rlang::sym(extraction)))/n()) %>% # Proportion of Responses
        filter(!is.na(!!rlang::sym(varname))) %>% # Remove Missing
        mutate(state = strsplit2(polyname, ",", 1)) # Extract state name
    if(id == "county") {
        data3$county <- strsplit2(data3$polyname, ",",2)
    }
    # Merge for coordinates
    if(id == "county"){
        map <- map_data('county') %>%
            mutate(polyname = paste0(region, ",", subregion, sep = "")) %>%
            select(-c(group, order, region, subregion))
    } else {
        map <- map_data('state') %>%
            mutate(polyname = paste0(region, ",", subregion, sep = "")) %>%
            select(-c(group, order, region, subregion))
    }
    if(latlong) {data3 <- left_join(data3, map, by = "polyname")}
    data3
}
# Theme
theme_map <- theme_bw() +
    theme(axis.text = element_blank(),
          axis.line = element_blank(),
          axis.ticks = element_blank(),
          panel.border = element_blank(),
          panel.grid = element_blank(),
          axis.title = element_blank(),
          legend.position = c(.95, .2),
          legend.title = element_blank(),
          legend.text = element_text(size = 8))
```

# Introduction

Approximately 1/3 of the population of the United States reports having less sleep on average than the recommended 7 hours a night [@cdc_2011; @liu_2016]. Chronic sleep deprivation is considered a serious public health issue, as insufficient sleep is associated with increased workplace related accidents [@dinges_1995; @rosekind_2010], obesity [@gang_2005; @knutson_2004], drowsy driving [@horne_1995; @howard_2004], cardiovascular disease [@ayas_2003; @mullington_2009], and a variety of other risks/conditions. Sleep deprivation is also correlated with decreased decision making [@harrison_2000] and sustained attention [@lim_2008], which may provide one explanation for some of the associated behavioral detriments. 

There have been sizable efforts on the part of the Centers for Disease Control (CDC) and National Sleep Foundation (NSF) to better understand the prevalance and costs of sleep deprivation through large-scale surveys across the United States. These surveys provide critical information for future policy and planning targeted interventions, and have led to some preliminary suggestions including employers tailoring shift-systems design [@cdc_2012], greater involvement by health-care providers [@cdc_2009], limiting active technology use before sleep [@gradisar_2013], and general increased public awareness of sleep deprivation. 

Communicating complex spatial data, such as nation-wide polls, requires a number of decisions and pre-processing steps before creating the final visualizations. This preliminary work can have large effects on the final product, leading to potentially different conclusions. The purpose of this brief report is to outline some practices which would help improve the transparency and clarity of the final report employing these visualizations. 

# Data

For this brief report we will the 2009 Behavioral Risk Factor Surveillance System (BRFSS) results collected by the CDC. The BRFSS is a yearly survey intended to measure health related behaviors and demographics such as tobacco use, seatbelt use, sleep related habits, etc. The 2009 BRFSS was collected through landlines only, with cellphones being added in 2011 to the survey sample. A total of 432,607 records were collected in this data set across 2231 of the total 3109 counties in the contiguous United States. The sleep related question that will be used here is presented below;

- “During the past 30 days, for about how many days have you felt you did not get enough rest or sleep? (number of days)”
- Response Options:
    - 0-30 days
    - Refuse to respond
    - Don't know
    - Missing  / Not asked

This dataset and question were selected due to their use in @grandner_2015, which will allow for some conrete discussion points and comparisons. The responses to this question were dichotomized, with participants reporting greater than 14 days of insufficient sleep being categorized as sleep deprived. This cutoff was chosen based on its use in previous research [@grandner_2015; @strine_2005] and the practical significance of it found in @edinger_2011. 

# Challenges 

## Sample Size

[@grandner_2015] Didn't discuss this, and many of the regions with high quintile were also the regions in which there was limited data

```{r echo = FALSE}
# State data used for state boundaries
state.df <- map_data("state")
sleep_2009$n.binom <- ifelse(sleep_2009$n<31, 1, 0)
ggplot(sleep_2009, aes(x=long, y=lat, group=polyname, fill=n.binom)) +
    geom_polygon(data = state.df, aes(x=long, y = lat, group = group),
                 color = NA, size = .6, fill = "grey") + # Make background grey
    geom_polygon(data = sleep_2009, aes(x=long, y=lat, group=polyname, fill=n.binom),
                 color = "grey27", size = .1, linetype = 4)+ # Fill in red
    geom_polygon(data = state.df, aes(x=long, y = lat, group = group, fill = NA),
                 color = "black", size = .6, fill = NA)+ # Put in state lines
    scale_fill_continuous(low = "white", high = "red")+
    coord_map("albers", lat0=39, lat1=45,
              xlim = c(-120, -73),
              ylim = c(25.12993,49.38323)) +
    ggtitle("Frequency of Responses") + 
    theme_map + 
    theme(legend.position = "none")
```

## Missing Data

Important to address, and quite hard to. It would be good at the very least to look at the proportion of the missing data (excluding refusal) per county and the proportion of refused to respond per county

```{r echo = FALSE, fig.width = 8}

```

## Quintiles

```{r echo = FALSE}
ggplot(sleep_2009, aes(x=long, y=lat, group=polyname, fill=prop)) +
    geom_polygon(color = "grey44", size = .01, linetype = 4)+
    geom_polygon(data = state.df, aes(x=long, y = lat, group = group, fill = NA),
                 color = "black", size = .6, fill = NA)+
    scale_fill_distiller(palette = "Spectral") + 
    coord_map("albers", lat0=39, lat1=45,
              xlim = c(-120, -73),
              ylim = c(25.12993,49.38323)) +
    ggtitle("Continuous Proportion of Sleep Deprivation") +
    theme_map
```

```{r echo = FALSE, fig.width = 8}
# Plot
sleep_2009$discrete <- quintiles(sleep_2009$prop)

ggplot(sleep_2009, aes(x=long, y=lat, group=polyname, fill=discrete)) +
    geom_polygon(color = "gray55", size = .1, linetype = 4)+
    geom_polygon(data = state.df, aes(x=long, y = lat, group = group, fill = NA),
                 color = "black", size = .6, fill = NA)+
    coord_map("albers", lat0=39, lat1=45,
              xlim = c(-120, -73),
              ylim = c(25.12993,49.38323)) +
    scale_fill_brewer(palette="YlOrRd")+
    ggtitle("Quintiles of Proportion of Sleep Deprivation") + 
    theme_map
```

## Adjusted Proportions

THIS NEEDS A LOT MORE IF GOIGN TO INCLUDE. MIGHT NOT HAVE THE TIME TO GO HAM ENOUGH

State level could use asmyptotic normal confidence intervals, but the smaller sample sizes in the county level analysis would need to use an exact test or bootstrap estimate (provided moderate n, ~15-30). Given the presence of numerous other variables not controlled for, and the differences in sampling error for older populations vs. younger populations, simply using age-adjusted estimates would likely not be sufficients. Instead using a multilevel approach such as the one outlined in @zhang_2014

## Transparency

All information used in creating the figures and analysis should be provided somewhere as well. For example, here I have used the same data and methodology as [@grandner_2015] for creating the quintile plot, yet have gotten a few sizable differences. This could be due to a variety of reasons, however without being able to compare code it is unclear whether this was due to a mistake on one of our parts, or a different decision in the preprocessing of the data that wasn't clearly described. 

# Conclusion



\pagebreak

# Code

```{r eval = FALSE}
BRFSS_geoextraction <- function(filepath, id = "county", position,
                                extraction, contiguous=TRUE,latlong=TRUE,
                                func = function(x) {mean(x, na.rm=T)}) {
    # Error Catching
    if(!grepl("state", tolower(position[1]))){stop("State must be first position.")}
    if(!is.character(filepath)) {stop("Filepath must be character")}
    if(!is.character(position)) {stop("Position must be character")}
    if(!is.character(extraction)) {stop("Extraction variable must be character name.")}
    if(length(extraction)!=1) {stop("Function currently only accepts one extracted var.")}
    if(!id %in% c("county", "state")) {stop("ID must be county or state.")}
    if(!is.function(func)){stop("Func must be a function.")}
    if(id == "county" & length(position) != 2) {
        stop("County level requires position to have State and County varialbe names. ")
    }
    # Setup
    require(SASxport)
    require(dplyr)
    require(maps)
    require(stringr)
    require(ggplot2)
    strsplit2 <- function(x, char, index){
        unlist(strsplit(x, char))[index]
    }
    clear_labels <- function(x) {
        if(is.list(x)) {
            for(i in 1 : length(x)) class(x[[i]]) <- setdiff(class(x[[i]]), 'labelled')
            for(i in 1 : length(x)) attr(x[[i]],"label") <- NULL
        }
        else {
            class(x) <- setdiff(class(x), "labelled")
            attr(x, "label") <- NULL
        }
        return(x)
    }
    # Read Data
    data <- read.xport(filepath) %>%
        clear_labels(.)
    # Subset
    keep <- c(position, extraction)
    keep.states <- if(contiguous) {
        c(15, 2, 66, 72, 78)
    } else {c()}
    # Remove Excess
    data2 <- data %>%
        select(one_of(keep)) %>% # Select columns of interest
        filter(!(!!rlang::sym(position[1])) %in% keep.states) %>% # Select States
        filter(!(is.na(!!rlang::sym(position[1])))) # remove missing states
    if(id == "county"){
        data2 <- data2 %>%
            filter(!(!!rlang::sym(position[2])) %in% c(777,999)) %>%
            filter(!(is.na(!!rlang::sym(position[2])))) %>%
            mutate(FIPS = as.numeric(paste0(
                !!rlang::sym(position[1]),
                str_pad(!!rlang::sym(position[2]),3,pad = "0"),
                sep = "")
            ))
    } else {
        data2 <- data2 %>%
            mutate(FIPS = !!rlang::sym(position[1]))
    }
    # Get FIPS Codes
    if(id == "county") {
        data(county.fips)
        county.fips$polyname <- sapply(county.fips$polyname, function(x) {
            unlist(strsplit(x, ":"))[1]
        })
        county.fips <- unique(county.fips)
        fips.codes <- county.fips
    } else {
        data(state.fips)
        state.fips$polyname <- sapply(state.fips$polyname, function(x) {
            unlist(strsplit(x, ":"))[1]
        })
        state.fips <- unique(state.fips)
        fips.codes <- as.data.frame(state.fips)
    }
    varname <- paste0(extraction, ".f", sep = "")
    # Merge By FIPS
    data3 <- data2 %>%
        left_join(fips.codes, by = c("FIPS" = "fips")) %>% # Get location string
        group_by(polyname,FIPS) %>% # State/County-wise operations
        summarize(!!varname := func(!!rlang::sym(extraction)), # Function
                  n = sum(!is.na(!!rlang::sym(extraction))), # Frequency of response
                  prop.responded = sum(!is.na(!!rlang::sym(extraction)))/n()) %>% 
        filter(!is.na(!!rlang::sym(varname))) %>% # Remove Missing
        mutate(state = strsplit2(polyname, ",", 1)) # Extract state name
    if(id == "county") {
        data3$county <- strsplit2(data3$polyname, ",",2)
    }
    # Merge for coordinates
    if(id == "county"){
        map <- map_data('county') %>%
            mutate(polyname = paste0(region, ",", subregion, sep = "")) %>%
            select(-c(group, order, region, subregion))
    } else {
        map <- map_data('state') %>%
            mutate(polyname = paste0(region, ",", subregion, sep = "")) %>%
            select(-c(group, order, region, subregion))
    }
    if(latlong) {data3 <- left_join(data3, map, by = "polyname")}
    # Output
    data3
}
```

\pagebreak

# References


